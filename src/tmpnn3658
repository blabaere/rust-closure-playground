use std::ops::{Add, Sub, Mult, Div};

fn evaluate<T : Add>(
	x1: T,
	x2: T,
	x3: T,
	x4: T,
	x5: T,
	x6: T,
	x7: T,
	x8: T,
	x9: T) -> T {
	x1 + 
	(13f64 * x2 / x3) + 
	x4 + 
	(12f64 * x5) - 
	x6 - 
	11f64 + 
	(x7 * x8 / x9) - 
	10f64
}

fn swap(values: &mut [f64;9], i: usize, j: usize) {
	let temp = values[i];

	values[i] = values[j];
	values[j] = temp;
}

fn permutation(values: &mut [f64;9], from: usize, to: usize) -> usize {
	if from == to {
		return check_result(values);
	}

	let mut count: usize = 0;
	for j in from..to {
		swap(values, from, j);
		count += permutation(values, from + 1, to);
		swap(values, from, j);
	} 

	return count;
}

fn check_result(values: &mut [f64;9]) -> usize {
	let result = evaluate(
		values[0],
		values[1],
		values[2],
		values[3],
		values[4],
		values[5],
		values[6],
		values[7],
		values[8]);
	if result == 66f64 {
		println!("{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}",
			values[0],
			values[1],
			values[2],
			values[3],
			values[4],
			values[5],
			values[6],
			values[7],
			values[8]);
		return 1;
	}
	return 0;
}

fn main() {
	let mut values = [1f64, 2f64, 3f64, 4f64, 5f64, 6f64, 7f64, 8f64, 9f64];
	let result_count = permutation(&mut values, 0, 9);

	println!("Result count: {:?}", result_count);
}
